{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"TBC/","text":"","title":"Coming Soon"},{"location":"advanced_options/additional_pairs/","text":"","title":"Advanced Algorithm Creation"},{"location":"advanced_options/additional_pairs/#additional-pairs","text":"<p>The additional pairs functionality allows you to have candle data available for other coins and timeframes, other than the current iteration of the run. This allows for more advanced strategies that take broader market conditions into account.</p> <p>To use this functionality, the <code>additional_pairs()</code> function needs to be defined in your strategy class. A <code>(\"coin\", \"timeframe\")</code> formatting is expected. See the code snippet below for an example, which defines that the 4h candle data of BTC/USDT needs to be available  in the <code>generate_indicators()</code> function. More combinations in the tuple formatting can be added, separated by commas. Note that each combination requires fetching the candle data, and thus might impact performance speed.</p>  <p>Multiple timeframes for the same coin?</p> <p>We recommend using only one timeframe per coin, and resampling upwards to achieve longer timeframes.</p>  <pre><code>@staticmethod\ndef additional_pairs():\n    \"\"\"\n    Specify The additional pairs in tuple format; (\"pair\", \"timeframe\"), separated by commas.\n    :return: list\n    \"\"\"\n    return [\n        (\"BTC/USDT\", \"4h\")\n    ]\n</code></pre>  <p>Next, the <code>generate_indicators()</code> function needs to be modified.  </p> <p>Firstly, a new argument is required, which makes the above specified coin/timeframe combinations available in a variable. <pre><code>def generate_indicators(self, dataframe: DataFrame, additional_pairs) -&gt; DataFrame:\n</code></pre></p> <p>Secondly, extract the pair from the variable. <code>add_btc_data</code> is a DataFrame, containing the usual OHLCV columns: <pre><code># Select the BTC/USDT pair from the additional_pairs dictionary\nadd_btc_data = additional_pairs['BTC/USDT']\n</code></pre></p> <p>Next, add indicators to the DataFrame in the traditional way: <pre><code># Add your indicators like usual\nadd_btc_data['rsi'] = ta.RSI(add_btc_data, timeperiod=14)\n</code></pre></p> <p>Finally, the DataFrame created above needs to be joined with the original <code>dataframe</code>, such that it can be used in the signal functions: <pre><code># Finally merge the additional btc data with the standard dataframe.\n# The new column will have the following format: ['&lt;column&gt;_&lt;pair&gt;_&lt;timeframe&gt;']\ndataframe = self.join_additional_data(dataframe, add_btc_data, self.timeframe, \"4h\")\n</code></pre></p>","title":"Additional pairs"},{"location":"advanced_options/additional_pairs/#full-example","text":"<p>Below is a full example of the usage of the additional pairs functionality. <pre><code>class MyStrategyAdvanced(Strategy):\n    \"\"\"\n    This is an example custom strategy for advanced users, that inherits from the main Strategy class\n    \"\"\"\n    @staticmethod\n    def additional_pairs():\n        \"\"\"\n        Specify The additional pairs in tuple format; (\"pair\", \"timeframe\")\n        :return: list\n        \"\"\"\n        return [\n            (\"BTC/USDT\", \"4h\")\n        ]\n\n    def generate_indicators(self, dataframe: DataFrame, additional_pairs) -&gt; DataFrame:\n        \"\"\"\n        :param dataframe: All passed candles (current candle included!) with OHLCV data\n        :type dataframe: DataFrame\n        :param additional_pairs: Possible additional pairs with specified timeframe\n        :type additional_pairs: dict\n        :return: Dataframe filled with indicator-data\n        :rtype: DataFrame\n        \"\"\"\n        # Select the BTC/USDT pair from the additional_pairs dictionary\n        add_btc_data = additional_pairs['BTC/USDT']\n        # Add your indicators like usual\n        add_btc_data['rsi'] = ta.RSI(add_btc_data, timeperiod=14)\n        # Finally merge the additional btc data with the standard dataframe.\n        # The new column will have the following format: ['&lt;column&gt;_&lt;pair&gt;_&lt;timeframe&gt;']\n        dataframe = self.join_additional_data(dataframe, add_btc_data, self.timeframe, \"4h\")\n\n        # EMA - Exponential Moving Average\n        dataframe['ema50'] = ta.EMA(dataframe, timeperiod=50)\n        dataframe['ema200'] = ta.EMA(dataframe, timeperiod=200)\n\n        return dataframe\n\n    def buy_signal(self, dataframe: DataFrame) -&gt; DataFrame:\n        \"\"\"\n        :param dataframe: Dataframe filled with indicators from generate_indicators\n        :type dataframe: DataFrame\n        :return: dataframe filled with buy signals\n        :rtype: DataFrame\n        \"\"\"\n        # BEGIN STRATEGY\n        dataframe.loc[\n            (\n                (\n                    (dataframe['ema50'] &gt; dataframe['ema200']) &amp;\n                    (dataframe['fastd'] &gt; dataframe['fastk']) &amp;\n                    (dataframe['volume'] &gt; dataframe['volume'].rolling(200).mean() * 4) &amp;\n                    (dataframe['rsi'] &gt; 50)\n                )\n                 &amp;\n                (dataframe['rsi_BTC/USDT_4h'] &lt; 30)     # additional pair usage\n            ),\n            'buy'] = 1\n        # END STRATEGY\n\n        return dataframe\n\n    def sell_signal(self, dataframe: DataFrame) -&gt; DataFrame:\n        \"\"\"\n        :param dataframe: Dataframe filled with indicators from generate_indicators\n        :type dataframe: DataFrame\n        :return: dataframe filled with sell signals\n        :rtype: DataFrame\n        \"\"\"\n        # BEGIN STRATEGY\n        dataframe.loc[\n            (\n                # BULL MARKET\n                (dataframe['ema50'] &gt; dataframe['ema200']) &amp;\n                (dataframe['rsi'] &gt; 60) &amp;\n                (dataframe['macd'] &lt; 0) &amp;\n                (dataframe['minus_di'] &gt; 0)\n\n            ),\n            'sell'] = 1\n        # END STRATEGY\n\n        return dataframe\n</code></pre></p>","title":"Full Example"},{"location":"advanced_options/additional_pairs/#custom-indicators","text":"<p>Looking for a specific indicator?</p> <p>Refer to this file for an up-to-date list of custom-coded indicators.</p>  <p>Renowned packages such as TA-Lib and QTPyLib provide a wide range of technical analysis tools. However, sometimes a specific indicator is missing. This often results in custom-coded indicators, based on their formal definitions.  These custom indicators are collected and made available to all users of the Engine. The aim is to constantly complement the list. We also encourage users that coded their own indicators to contribute to this collection.</p>","title":"Custom Indicators"},{"location":"advanced_options/additional_pairs/#example","text":"<p>To use the indicators, import the corresponding file at the top of your strategy file: <pre><code>from modules.public import technical_indicators as indicator\n</code></pre></p> <p>Call the desired method in the <code>generate_indicators()</code> function like so: <pre><code># Ichimoku Cloud\nichimoku_cloud = indicator.ichimoku_cloud(dataframe, conversion_length=9, base_line_length=26, lead_length=52, displacement=26)\ndataframe['ichi_conversion'] = ichimoku_cloud[0]\ndataframe['ichi_base_line'] = ichimoku_cloud[1]\ndataframe['ichi_lead_line1'] = ichimoku_cloud[2]\ndataframe['ichi_lead_line2'] = ichimoku_cloud[3]\n</code></pre></p>","title":"Example"},{"location":"advanced_options/hyperoptimalization/","text":"","title":"[experimental] Hyperparameter optimization"},{"location":"advanced_options/hyperoptimalization/#usage","text":"<p><code>engine --alpha-hyperopt=true</code></p> <p>Example strategy: <pre><code># Mandatory Imports\nimport talib.abstract as ta\nfrom pandas import DataFrame\nfrom backtesting.strategy import Strategy\nfrom modules.public.hyperopt_parameter import integer_parameter, float_parameter\nfrom modules.public.trading_stats import TradingStats\n\n\nclass MyStrategy(Strategy):\n    # parameters\n    buy_rsi = integer_parameter(default=40, low=10, high=50, step=1)\n    sell_rsi = float_parameter(default=70., low=60., high=80., step=1.)\n\n    def generate_indicators(self, dataframe: DataFrame, additional_pairs=None) -&gt; DataFrame:\n        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n        dataframe['ema5'] = ta.EMA(dataframe, timeperiod=5)\n        dataframe['ema21'] = ta.EMA(dataframe, timeperiod=21)\n\n        return dataframe\n\n    def buy_signal(self, dataframe: DataFrame) -&gt; DataFrame:\n        dataframe.loc[\n            (\n                    (dataframe['rsi'] &lt; self.buy_rsi) &amp;\n                    (dataframe['ema5'] &lt; dataframe['ema21']) &amp;\n                    (dataframe['volume'] &gt; 0)\n            ),\n            'buy'] = 1\n\n        return dataframe\n\n    def sell_signal(self, dataframe: DataFrame) -&gt; DataFrame:\n        dataframe.loc[\n            (\n                    (dataframe['rsi'] &gt; self.sell_rsi) &amp;\n                    (dataframe['volume'] &gt; 0)\n            ),\n            'sell'] = 1\n\n        return dataframe\n\n    # LOSS function\n    def loss_function(self, stats: TradingStats):\n        winning_trades = len(list(filter(lambda trade: trade.profit_ratio &gt; 1., stats.trades)))\n        avg_profit = sum(map(lambda trade: trade.profit_ratio, stats.trades)) * 100.\n        amount_of_trades = len(stats.trades)\n        if amount_of_trades == 0:\n            return 1.\n        win_ratio = winning_trades / amount_of_trades\n        return -avg_profit * win_ratio\n</code></pre></p>","title":"Usage"},{"location":"advanced_options/hyperoptimalization/#parameters","text":"","title":"Parameters"},{"location":"advanced_options/hyperoptimalization/#integer_parameter","text":"<pre><code>buy_rsi = integer_parameter(default=40, low=10, high=50, step=1)\n</code></pre> <p>Defines integers within a specified range. The boundaries of this range are defined by the  <code>low</code> and <code>high</code> parameters and the step size by the <code>step</code> parameter. During hyper-opt  all the defined integer values will be 'tested' and the value where the <code>loss_function()</code> is  minimal (in combination with other hyper-opt parameters) will be presented after the  hyper-opt is  finished. </p> <p>When <code>integer_parameter()</code> is used but hyper-opt is not enabled through the command line, the  engine will use the defined <code>default</code> value.</p>  <p>Note: make sure that when using a parameter function, that these variables are used when  populating the buy/sell signals (see example strategy above)</p>","title":"integer_parameter()"},{"location":"advanced_options/hyperoptimalization/#float_parameter","text":"<pre><code>sell_rsi = float_parameter(default=70., low=60., high=80., step=1.)\n</code></pre> <p>Defines floats within a specified range. Works similar to <code>integer_paramater()</code> except that  <code>float_parameter()</code> uses floats instead of integers. This allows the hyper-opt to be able to  find a more precise optimal value.</p>","title":"float_parameter()"},{"location":"advanced_options/hyperoptimalization/#loss-function","text":"<p><pre><code>def loss_function(self, stats: TradingStats):\n        winning_trades = len(list(filter(lambda trade: trade.profit_ratio &gt; 1., stats.trades)))\n        avg_profit = sum(map(lambda trade: trade.profit_ratio, stats.trades)) * 100.\n        amount_of_trades = len(stats.trades)\n        if amount_of_trades == 0:\n            return 1.\n        win_ratio = winning_trades / amount_of_trades\n        return -avg_profit * win_ratio\n</code></pre> Calculation method used for finding the loss. Goal of the hyper-opt is to minimize the loss  calculated in this function. The calculation method can be changed to hyper-opt with another  type of loss, but we recommend using this implementation. </p>","title":"Loss function"},{"location":"installation_and_updating/installation/","text":"<p>If you want to install the Engine, all you have to do is to run a single command in your terminal. Based on which operating system you are using, you follow the instructions below. For MacOS follow the instructions below. Are you using Windows? Take a look at the instructions in the Windows section.</p>","title":"Installation"},{"location":"installation_and_updating/installation/#macos","text":"<p>If your operating system is macOS, please execute the following command from a terminal:</p> <pre><code>curl -fsSL https://engine-store.ams3.digitaloceanspaces.com/installing_macos.sh | /bin/bash\n</code></pre> <p>This command downloads and runs the script that installs the Engine. If you want to know the details, read through the installation script.</p> <p>For more detailed instructions, please see the video below!</p> <p></p>","title":"MacOS"},{"location":"installation_and_updating/installation/#linux","text":"<p>If your operating system is Linux (any distro), please execute the following command from a terminal:</p> <pre><code>curl -fsSL https://engine-store.ams3.digitaloceanspaces.com/installing_linux.sh | /bin/bash\n</code></pre> <p>This command downloads and runs the script that installs the Engine. If you want to know the details, read through the installation script.</p>","title":"Linux"},{"location":"installation_and_updating/installation/#windows","text":"<p>If your operating system is Windows, the command you have to run is different. To install the Engine, open a Powershell window as Administrator. Then, execute the following command:</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://ams3.digitaloceanspaces.com/engine-store/install-windows.ps1'))\n</code></pre> <p>This command downloads and runs the script that installs the Engine. If you want to know the details, read through the installation script.</p> <p>For more detailed instructions, please see the video below!</p> <p></p>","title":"Windows"},{"location":"installation_and_updating/running/","text":"<p>Once you have successfully installed the Engine, it is time to run it. Open a terminal (MacOS) or Powershell (with administrator rights) (Windows), and execute the following commands.</p> <p>To create your project in a new folder, use the following command: <pre><code>engine init &lt;YOUR_DIRECTORY_NAME&gt;\n</code></pre></p> <p>Move to the directory you just created with the following command: <pre><code>cd &lt;YOUR_DIRECTORY_NAME&gt;\n</code></pre></p> <p>Then, to run the Engine, simply execute the following command: <pre><code>engine\n</code></pre></p> <p>Once you have done so, the Engine will run with a sample strategy. The results of the backtest will appear on your screen. A detailed explanation of the results can be found in Section 2.3: Results explained.</p>","title":"Running"},{"location":"installation_and_updating/running/#advanced-running-options","text":"<p>There are multiple parameters you can add on to the executable command, in order to customize the running of the Engine. Here is a short overview of all possibilities.</p> <ul> <li> <p>Display the overview of all possible parameters of the engine: <pre><code>engine -h\n</code></pre></p> </li> <li> <p>Set the starting capital to 500: <pre><code>engine -cap 500\n</code></pre></p> </li> <li> <p>Set the backtesting from date to 14th of October 2020: <pre><code>engine -from \"2020-10-14\"\n</code></pre></p> </li> <li> <p>Set the backtesting to date to first of December 2021: <pre><code>engine -to \"2021-12-01\"\n</code></pre></p> </li> <li> <p>Set the stoploss to -50: <pre><code>engine -sl -50\n</code></pre></p> </li> <li> <p>Set the stoploss type to trailing: <pre><code>engine -sl_type \"trailing\"\n</code></pre></p> </li> <li> <p>Turn off the plotting functionality: <pre><code>engine -no-plots True\n</code></pre></p> </li> <li> <p>Turn on the hyperparameter optimization functionality: <pre><code>engine -hy True\n</code></pre></p> </li> <li> <p>Set the number of trials for the hyperparameter optimization functionality: <pre><code>engine -hy True -nt 50\n</code></pre></p> </li> <li> <p>Export the backtesting results to a json file: <pre><code>engine -ex True\n</code></pre></p> </li> <li> <p>Set the resources directory (that contains the config file): <pre><code>engine -r \"./resources\"\n</code></pre></p> </li> <li> <p>Set the strategies directory (that contains the strategy file): <pre><code>engine -sf \"./strategies\"\n</code></pre></p> </li> <li> <p>Run the Engine without Engine Use Statistics: <pre><code>engine -nostat True\n</code></pre></p> </li> </ul> <p>The Engine Use Statistics pertains to the statistics we collect about the Engine usage. We only collect completely anonymised user ID's, current Engine version, and when the Engine was run.</p>","title":"Advanced Running Options"},{"location":"installation_and_updating/updating/","text":"<p>The Engine is updated regularly. For optimal performance make sure you are running the newest version of the Engine. With the newest version, you\u2019re always up-to-date! When an update is available, and you run the Engine using the commands explained in the previous section, it will notify you in the terminal with a message similar to this: <pre><code>[WARNING] Update available v0.7.7 \u2192 v0.7.9\n</code></pre></p> <p>This means that you are running an outdated version of the Engine. You can simply update the Engine by re-using the commands you used when installing the Engine, as found in Section 1.1: Installation.</p>","title":"Updating"},{"location":"knowledge_library/changelog/","text":"","title":"Changelog"},{"location":"knowledge_library/changelog/#version-07","text":"<p>Stable beta release with added features:</p> <ul> <li>Complete redesign of backtesting results overview</li> <li>BTC and ETH as base pairs</li> <li>Open and Closed Trades log</li> <li>Shortest / average / longest trade duration statistic</li> <li>Changed the OHLC plots from bars to candlesticks</li> <li>Improved download speed of candles from exchanges</li> <li>Better and timelier logging of engine functionality</li> <li>Improved max seen drawdown and max realised drawdown</li> <li>Additional Pairs</li> <li>Improved data loading speed</li> <li>Improved plotting speed</li> <li>Buy &amp; Hold Drawdown statistic</li> <li>Winning weeks statistic</li> <li>Portfolio equity plot</li> <li>(Experimental) Hyperparameter optimization</li> <li>(Experimental) Self contained executables &amp; installers</li> </ul>","title":"Version 0.7"},{"location":"knowledge_library/changelog/#version-06","text":"<p>Stable beta release with added features:</p> <ul> <li>Rigorous testing and improvement of all current statistics</li> <li>Refactoring of the entire engine</li> <li>Improvement of plot readability</li> <li>Improvement of Realized Drawdown &amp; Seen Drawdown statistic</li> <li>Average numbers of trades per day</li> </ul>","title":"Version 0.6"},{"location":"knowledge_library/changelog/#version-05","text":"<p>Stable beta release with added features:</p> <ul> <li>Fixed wrong avg trade duration</li> <li>Changed the way 'spend_amount' (trade value for new trade) is defined. This will prevent the portfolio from becomming unbalanced (e.g. 1/4 budget in one trade and 3/4 budget in another trade)</li> <li>Old: (1 / available_spaces) * budget</li> <li>New: (1 / amount_of_pairs) * budget </li> <li>Fixed incorrect drawdown calculations for 'backtest results' </li> <li>Fixed incorrect drawdown calculations for 'per coin insights'</li> <li>Changed profit percentage columns for 'per coin insights'</li> <li>Now consists of 'avg profit', 'cum profit' and 'total profit'</li> <li>Profit percentages only include closed trades and not open trades (these are shown in 'left open trades' table)</li> <li>Renamed metrics in results table:</li> <li>Max drawdown bad trade train -&gt; most consecutive losses</li> <li>Most drawdown 1 trade -&gt; Worst trade</li> <li>Seen drawdown from -&gt; Max seen drawdown from</li> <li>Seen drawdown to -&gt; Max seen drawdown to</li> <li>[Removed] Max drawdown trades</li> <li>Added average marketchange of BTC and whitelisted coins</li> <li>Fixed incorrect use of downloaded .json data</li> <li>Updated dynamic stoploss warning</li> <li>Changed plots argument to boolean</li> <li>Removed if statement from advanced_strategy</li> </ul>","title":"Version 0.5"},{"location":"knowledge_library/changelog/#version-04","text":"<p>Stable beta release with added features:</p> <ul> <li>Several bugfixes</li> <li>Enhanced backtesting overview </li> <li>Added plotting possibilities </li> <li>Added Dynamic- and Trailing stoploss </li> <li>Added QtpyLib </li> <li>Development Image Publishing pipeline</li> <li>Added CLI support</li> </ul>","title":"Version 0.4"},{"location":"knowledge_library/changelog/#version-03","text":"<p>Stable beta release with added features:</p> <ul> <li>140% decrease of backtest time.</li> <li>docker-compose file with proper volume mounting</li> <li>new progress bars</li> <li>checks for missing ticks</li> <li>small optimizations</li> <li>moved docs to separate repository</li> <li>dynamic stoploss</li> </ul>","title":"Version 0.3"},{"location":"knowledge_library/changelog/#version-02","text":"<p>Stable beta release with added features:</p> <ul> <li>Added fee-support</li> <li>Improved overall results overview</li> <li>Improved documentation</li> </ul>","title":"Version 0.2"},{"location":"knowledge_library/changelog/#version-01","text":"<p>First release including features:</p> <ul> <li>Easy strategy customization</li> <li>OHLCV data in dataframe</li> <li>Release / test pipelines</li> <li>Progress bar for time indication</li> <li>Enhanced backtest results</li> <li>Automatically downloading data</li> <li>Configurable base currency</li> <li>Documentation setup</li> <li>Dockerized the whole engine</li> </ul>","title":"Version 0.1"},{"location":"knowledge_library/faq/","text":"","title":"Frequently Asked Questions"},{"location":"knowledge_library/faq/#why-is-the-default-fee-set-at-025","text":"<p>The default value of the fee is 0.25% for both entries and exits. That means a round trip for a trade (buy and sell)  costs 0.5%. This value accounts for higher commissions on 3rd partner platforms and exchanges. Backtesting will therefore  more closely resemble a live trading environment.</p>","title":"Why is the default fee set at 0.25%"},{"location":"knowledge_library/faq/#how-do-i-disable-roi-or-sl","text":"<p>Currently there is no 'toggle'. However, you can still achieve the same results by giving those settings an unrealistic high value. Essentially, there are disabled in that case, as they will never trigger.</p>","title":"How do I disable ROI or SL?"},{"location":"knowledge_library/term_sheet/","text":"","title":"Termsheet"},{"location":"knowledge_library/term_sheet/#hold","text":"<p>A Hold is holding your assets. The assets itself can be held for a considerable amount of time. A hold basically just means that if you hold it, you keep it in your wallet for a certain amount of time.</p>","title":"Hold"},{"location":"knowledge_library/term_sheet/#fiat","text":"<p>Fiat is any kind of government issued currency that is not backed by any kind of commodity such as gold or silver.</p>","title":"Fiat"},{"location":"knowledge_library/term_sheet/#margin","text":"<p>Margin trading is using funds of other traders, who earn interest based on the market demand for funds. Margin trading is less common among cryptocurrency in comparison to the stock market however, it certainly exists.</p>","title":"Margin"},{"location":"knowledge_library/term_sheet/#short","text":"<p>A short (or shorting) means that you're aiming to sell an asset at a short-ratio in the aims of buying it when it hits a lower price. Basically, it is short-term selling; you buy in at a price, aiming to sell higher, wanting to buy in lower.</p>","title":"Short"},{"location":"knowledge_library/term_sheet/#long","text":"<p>A long is taking on the position of investing in the same way as when you buy a stock, you buy it in at a position where you are comfortable with, aiming to let it increase over time (months to years, usually).</p>","title":"Long"},{"location":"knowledge_library/term_sheet/#bid","text":"<p>A bid is the maximum price that a buyer is willing to pay for an asset. The bid price in most exchanges is depicted within the order book.</p>","title":"Bid"},{"location":"knowledge_library/term_sheet/#ask","text":"<p>'Ask' refers to the minimum price a seller is willing to receive for their assets on the market. Just like with the 'bid', the 'ask' is depicted within the order book.</p>","title":"Ask"},{"location":"knowledge_library/term_sheet/#spread","text":"<p>A spread is the difference between the buy and sell prices that are quoted. Within spreads there are spread bets in which a trader makes a decision on whether the price of the coin might go up or down and will then make a profit or a loss based on whether their prediction is correct or not. The greater the price movement, the greater the profit or loss.</p>","title":"Spread"},{"location":"knowledge_library/term_sheet/#fee","text":"<p>A fee is the cost of the transaction costs when buying and/or transferring from one wallet to another wallet. Most exchanges have an innate fee based off a percentage, which you then have to pay upon every transaction.</p>","title":"Fee"},{"location":"knowledge_library/term_sheet/#realised-drawdown","text":"<p>The realised drawdown is the percentage between the peak and the subsequent trough, meaning that if a trading account has 1000 USD in it, and the funds drop to 900USD before moving back to anything above 1000USD, then the trading account witnessed a 10% drawdown. If the trader sells at that point, it is a realised drawdown, given it has come to realisation.</p>","title":"Realised drawdown"},{"location":"knowledge_library/term_sheet/#seen-drawdown","text":"<p>The seen drawdown is the percentage between the peak and the same as a realised drawdown, except that with the realised drawdown, you actually sold, and witnessed a drawdown. The seen drawdown is merely the peak-to-trough that has been witnessed.</p>","title":"Seen drawdown"},{"location":"knowledge_library/term_sheet/#market-change","text":"<p>A market change depicts the change in the market from a 'bear' market, a stable market, or a 'bull' market. The meaning between these is that in a 'bear' market, the market itself is declining and it encourages selling, however crypto can be bought at a lower price during this market. In contrary, a 'bull' market encourages buying, but selling during a 'bull' market, profits can easily be made given the market trend is on the uprise. A stable market is a market that is mostly stable, slightly going up and down; a change between markets is what would be called a market change.</p>","title":"Market change"},{"location":"knowledge_library/term_sheet/#ta","text":"<p>Technical Analysis (TA) is the historical analysis of a cryptocurrency, describing and analyzing the historic price and volume to predict a future movement of assets via the hands of several indicators such as the EMA, MACD, UO, and so forth.</p>","title":"TA"},{"location":"knowledge_library/term_sheet/#roi","text":"<p>Return On Investment (ROI) is widely known in cryptocurrency, it is a ratio or percentage value that represents profitability or efficiency of a certain trade or agreement. It is a tool that's widely used - including strategies for DemaTrading. ROI can be portrayed in an absolute ratio (such as 0.35) or a value percentage (such as 35%). The calculation for ROI is as followed:</p> <pre><code>ROI = (Current Value - Total Cost) / Total Cost\n</code></pre> <p>A simple example would be as followed:</p> <p>Mary bought 100 BTC at a price of 1,000 USD, paying 10 dollars for each BTC. If the current price of BTC is 20 dollars, Mary would have reached an ROI of 1.00 or 100%.</p> <p>However, there are some limitations to ROI in itself as it does not take time in consideration. This means the efficiency is lower than it should be if a lot of time passes in comparison to an earlier timeslot. Let's show you via the hands of a quick example, using Mary again!</p> <p>Mary's BTC is worth 18 per BTC after 6 months of her initial investment of 1,000 USD (100 BTC). She waits another 6 months for a total of 12 months, causing the BTC to be worth 19 USD per BTC after the 12 months. During this period there were ups and downs, and thus a second trade could have made Mary more money if she had traded at the 6 month mark; the time lost along with the fact she could've traded yet again lowering the efficiency. </p>","title":"ROI"},{"location":"knowledge_library/term_sheet/#stop-loss","text":"<p>A Stop-Loss is an advanced order that is used by traders that limits any form of additional losses. When a specific price is met, the order is triggered.</p> <p>An example would be that buying in at 100 would stop any form of losses at 95. In this case the stop-loss treshold would be -5%. Similarly, it can be done for a profit where one can set it to +5%, which in turn would mean the profit would be capped at 105.</p>","title":"Stop Loss"},{"location":"knowledge_library/term_sheet/#ohlcv","text":"<p>OHLCV, also known as:</p> <ul> <li>Open: the moment at which the candle starts.</li> <li>High: the highest point during the candle, usually depicted with a thin green line (if the current close went up in comparison to the previous close) or a thin red line (if the current close went down in comparison to the previous close) that sticks out of the close.</li> <li>Low: the lowest point during the candle, usually depicted with a thin red line (if the current close went down in comparison to the previous close) or a thin green line (if the current close went up in comparison to the previous close) that sticks out of the close. </li> <li>Close: the point at which the candle closes, the close dictates whether a candle ends up green or red after comparing it to the previous close (green if up, red if down)</li> <li>Volume: the total amount traded during this time period.</li> </ul> <p>Can be used to trade in an easy fashion as it takes all five of these time points in consideration.</p>","title":"OHLCV"},{"location":"knowledge_library/trading_basics/","text":"","title":"Trading 101"},{"location":"knowledge_library/trading_basics/#a-basic-guide-to-trading","text":"","title":"A basic guide to trading."},{"location":"knowledge_library/trading_basics/#getting-started-with-trading","text":"<p>To start with trading, the first thing you need is volume in one of the coins you desire to trade with. With this volume, you can both sell and buy; selling means selling your current liquidity (in the form of crypto) at the price given at the current prize (usually displayed within the candle and via the book order). Buying means buying, simply buying the asset at the current prize which - just like selling - shows via the candles and the book order.</p> <p>This in itself is a trade. Candles and book orders will display real-time buy and sell orders that indicate your loss or profit from the point you've bought at. More on these terms can be found under basic terms.</p>","title":"Getting started with trading."},{"location":"knowledge_library/trading_basics/#so-what-does-that-mean-for-me","text":"<p>In itself it means that with the right buys at the right time and the right sales at the right time, you can earn money via your assets (in crypto). Trading has a lot of success stories and we aim to assist further in that.</p>","title":"So what does that mean for me?"},{"location":"knowledge_library/trading_basics/#so-what-can-dematrading-do-for-me","text":"<p>As explained on other pages, DemaTrading can assist you in automating and optimizing your strategy. A strategy is an approach to the current market, which will look at several factors such as ROI, the current values, the stop-loss, and so forth. The benefits of using automatized trading is that it will automatically do these processes for you even when you're not there to perform the actual trade.</p> <p>That means that even if you are far away, the bot itself will still continue on to perform trades given the configuration you've given it. The configuration itself can be adjusted fairly easily which can be seen in pages such as the strategy examples page or the page of creating strategies. </p>","title":"So what can DemaTrading do for me?"},{"location":"knowledge_library/trading_basics/#i-keep-seeing-all-these-terms-and-im-not-sure-what-they-all-mean","text":"<p>Don't be afraid! There are a lot of terms that can frighten you, but most of them will be described in the basic term sheet. We aim to give you more knowledge for both you and your strategies; this in return, allows you to improve and invest that knowledge into a further optimized bot.</p>","title":"I keep seeing all these terms and I'm not sure what they all mean!"},{"location":"knowledge_library/troubleshooting/","text":"","title":"Strategy Mistakes"},{"location":"knowledge_library/troubleshooting/#getting-previous-candle","text":"<p>You can access data from the previous candle using <code>.shift(1)</code>: <pre><code>previous_candle = dataframe['close'].shift(1)\n</code></pre></p>","title":"Getting Previous Candle"},{"location":"knowledge_library/troubleshooting/#getting-macd-values","text":"<p>Some indicators return multiple values. This means that you have to 'unpack' the results of that indicator. See the example below, demonstrated with MACD. <pre><code>macd = ta.MACD(dataframe)\ndataframe['macd'] = macd['macd']\ndataframe['macdsig'] = macd['macdsignal']\ndataframe['macdhist'] = macd['macdhist']\n</code></pre></p>","title":"Getting MACD values"},{"location":"knowledge_library/troubleshooting/#setting-custom-indicator-values","text":"<p>Many indicators use default values for certain parameters. However, you can overwrite these values to obtain the desired behaviour. See below for an example using MACD. <pre><code>macd = ta.MACD(dataframe, fastperiod=10, slowperiod=20, signalperiod=9)\n</code></pre> Check the TA-Lib documentation for an overview of  all indicators, their parameters and their default values.</p>","title":"Setting custom indicator values"},{"location":"knowledge_library/troubleshooting/#using-mean","text":"<p>If you are using .mean() in for example <code>dataframe['volume'].mean()</code> you should always add the <code>.rolling()</code> before the .mean, otherwise the average would be based on ALL of the available data from the dataframe. See the code example below: <pre><code>dataframe['volume'].rolling(14).mean()\n</code></pre> In this case, we use the last 14 candles to calculate the average volume. </p>","title":"Using .mean()"},{"location":"publishing_your_strategy/publishing_your_strategy/","text":"<p>At DemaTrading.ai we aim to facilitate you - as an algorithm supplier - with a platform for your algorithms, and strategies to flourish. Founded with the vision in mind to be able to be a partner for everyone, no matter the experience. We help traders to automate, optimise, and monetise their trading strategies. No experience with trading? No experience with the complicated programming? We can and will help you in your learning journey! </p>","title":"How we can help you with the monetisation of your algorithm"},{"location":"publishing_your_strategy/publishing_your_strategy/#for-manual-traders","text":"<p>If you have a strategy that you've created manually, stuck in your mind or written on paper, but you're uncertain as to how to automate it and to make it work with automated trading fret not! We can automate it for you, depending on your strategy, and support you by answering all possible questions you may have through our engine support channel where we aim to solve your issue as soon as possible.</p>","title":"For manual traders"},{"location":"publishing_your_strategy/publishing_your_strategy/#for-algorithm-creators","text":"<p>As the algorithm creator, you'll be able to host your strategies, enjoy profit off it, and receive both instant feedback and optimization of your algorithm. Whether you have the trading knowledge or the coding knowledge, DemaTrading is there for you.</p> <ol> <li>Sign contract: you sign a contract with us, which will be provided after a brief conversation with us (follows the local laws and the European laws; we're registered in Amsterdam).</li> <li>Test and validate: we test the algorithm you provide us and test it, see whether it is valid or not and whether it is a strategy all parties can profit off of.</li> <li>Optimize: we or you - in conjunction with us - optimize the algorithm, ensure it can work on our platform without any errors.</li> <li>Sandbox: in the sandbox period, we dry-run the algorithm, ensuring that it will actually function and that it will be profitable for everyone involved.</li> <li>Going live: the final step. Your algorithm is now live! Time to earn some money!</li> </ol> <p>Once in the live setting, your algorithm will be making profit over every single trade made with the algorithm, the amount you earn is based on the trades per month, the volume invested in your algorithm. Based off the volume and the trades per month, you'll receive a monthly income that in turn is a percentage of the fee of every trade.</p> <p>Disclaimer: the fee in the algorithm needs to be 0.0025 (0.25%)</p>","title":"For algorithm creators"},{"location":"publishing_your_strategy/publishing_your_strategy/#how-do-i-know-whether-my-bot-is-good","text":"<p>When backtesting your bot, the projected drawdown will be key. If your bot reaches a -80% drawdown and ends any and all time periods with losses rather than profits, then it won't be going far. However, if your bot only reaches a -10% dropdown and ends up with a solid profit on the vast majority of the trades made then your bot will be able to be pushed live once it makes it through the aforementioned 5 steps.</p>","title":"How do I know whether my bot is good?"},{"location":"your_first_strategy/editing_your_configuration/","text":"<p>The backtest has a lot of configurable parameters, which are all defined in the config file <code>config.json</code>. The standard <code>config.json</code> looks like this: <pre><code>{\n  \"exchange\": \"binance\",\n  \"timeframe\": \"5m\",\n  \"max-open-trades\": 3,\n  \"starting-capital\": 1000,\n  \"backtesting-from\": \"2021-03-11\",\n  \"backtesting-to\": \"2021-03-15\",\n  \"backtesting-till-now\": false,\n  \"stoploss-type\": \"standard\",\n  \"stoploss\": -10,\n  \"roi\": {\n    \"0\": 5,\n    \"60\": 4,\n    \"120\": 3\n  },\n  \"pairs\": [\"BTC/USDT\", \"LTC/USDT\", \"ETH/USDT\"],\n  \"currency\": \"USDT\",\n  \"fee\": 0.25,\n  \"strategy-name\": \"MyStrategy\",\n  \"strategies-folder\": \"strategies\",\n  \"plots\": true,\n  \"mainplot_indicators\": [\"ema5\", \"ema21\"],\n  \"subplot_indicators\": [\"volume\"]\n}\n</code></pre> To change something in the configuration, just simply modify the value on the right (after <code>\"[PARAMETER]\":</code>).</p>","title":"Configuration"},{"location":"your_first_strategy/editing_your_configuration/#parameters","text":"","title":"Parameters"},{"location":"your_first_strategy/editing_your_configuration/#exchange","text":"<p>The <code>exchange</code> that is used to retrieve OHLCV data from. Currently, we only support the <code>\"binance\"</code> exchange.</p>","title":"Exchange"},{"location":"your_first_strategy/editing_your_configuration/#timeframe","text":"<p>Timeframe that is used to populate the indicators and buy/sell signals. A <code>timeframe</code> can be defined by either using  minutes <code>m</code>, hours <code>h</code> or days <code>d</code>. We recommend using one of the following timeframes: <code>1m</code>, <code>5m</code>, <code>15m</code>, <code>30m</code> or <code>1h</code>. </p>","title":"Timeframe"},{"location":"your_first_strategy/editing_your_configuration/#max-open-trades","text":"<p>The maximum amount of trades that can be open simultaneously. The engine is designed such that it can only have a  maximum of one open trade per pair, which means that within all open trades there can never be a duplicate pair. Because of this restriction buy signals can be rejected, since it could be the case that the pair you want to open a new trade for has already an open trade.</p> <p>The <code>max-open-trades</code> is used to calculate the stake amount for a certain trade. The standard way of calculating the stake  amount is by: <pre><code>stake-amount = (1 / max-open-trades) * realised-profit\n</code></pre></p> <p>But when calculating the stake amount we also have to factor in the amount of trading pairs, since this can influence  the way that the stake amount is determined. We explain the relation between the max. open trades and amount of trading pairs in the following three scenarios:</p> <ol> <li> <p>Max. open trades &gt; amount of trading pairs: because we can never reach the max open trades (not enough trading pairs),    the value for max. open trades will be set equal to the amount of trading pairs.</p> </li> <li> <p>Max. open trades &lt; amount of trading pairs: when this occurs certain buy signals can be rejected. Above we     described that the engine can not open multiple trades on the same pair. In this scenario it can also happen that a     pair that does not have an open trade, wants to open a trade (due to a buy signal) but gets rejected. This happens    when max. open trades is reached, because then all new buy signals are rejected.</p> </li> <li> <p>Max. open trades == amount of trading pairs: nothing changes.</p> </li> </ol>","title":"Max. open trades"},{"location":"your_first_strategy/editing_your_configuration/#starting-capital","text":"<p>The amount of capital that the bot is able to use for trading.</p>","title":"Starting capital"},{"location":"your_first_strategy/editing_your_configuration/#backtesting-period","text":"<p>The specified period where the bot will be analysed on. Here, <code>backtesting-from</code> will indicate the starting point and  <code>backtesting-to</code> will indicate the ending point of the backtesting period. Both timestamps are defined in the  <code>config.json</code> as YYYY-MM-DD. </p> <p>If you want to test the bot until your current date, you can enable the boolean  <code>backtesting-till-now</code> by setting its value to <code>true</code>. It will then backtest from the defined  <code>backtesting-from</code> until your current point in time (specific to the minute).</p>","title":"Backtesting period"},{"location":"your_first_strategy/editing_your_configuration/#stoploss","text":"<p>When using a stoploss you can use three different types, which can be altered by changing the value for  <code>stoploss-type</code>: 1. <code>\"standard\"</code>: this stoploss type is activated by default and prevents the bot from dealing with great losses.     When this stoploss is selected a trade will close automatically when the profit percentage for that trade is equal to     or drops below the configured <code>stoploss</code>.</p> <ol> <li><code>\"trailing\"</code>: this stoploss type enables a trailing stoploss. When using this stoploss type a stoploss value 'SL'    is calculated at every candle. This SL will indicate the 'sell price' at which a trade needs to be closed. If the     traded pair (e.g. BTC/USDT) is equal or drops below this price, the corresponding trade will be closed. SL is     calculated at every candle by: <code>SL = candle-high * (1 - trailing-percentage)</code>. </li> <li><code>candle-high</code> is the highest price seen in that specific candle.</li> <li><code>trailing-percentage</code> is the stoploss percentage defined by <code>stoploss</code>in the <code>config.json</code>.</li> </ol> <p>The algorithm used for trailing stoploss is defined as follows:    1. TSL is defined as the SL of first candle    2. Get SL of next candle    3. If SL for next candle is HIGHER than TSL:        - TSL = next candle SL        - back to Step 2.    4. If SL for next candle is LOWER than TSL:        - back to Step 2.</p> <ol> <li><code>\"dynamic\"</code>: stoploss type which can be defined in the strategy class. See <code>my_strategy_advanced.py</code> for an    example on how this stoploss needs to be defined. The basic use is that for each candle a stoploss price needs to be    defined and if the candle-low (lowest seen price in that specific candle) is equal or drops below the defined    stoploss price, that trade will be closed. <p>Note: if <code>stoploss-type</code> is set to <code>\"dynamic\"</code> but the stoploss function in the strategy class is either undefined or defined wrong, the <code>stoploss-type</code> will be automatically changed to <code>\"standard\"</code> and will use the <code>stoploss</code> percentage from the <code>config.json</code>.</p>  </li> </ol>","title":"Stoploss"},{"location":"your_first_strategy/editing_your_configuration/#roi","text":"<p>Defines the Return On Investment (<code>roi</code>) sell signals. See the  Termsheet for more information. ROI is used to close a trade when a certain ROI is reached. In addition, you can also specify after how many minutes the trade should  be closed. In the <code>config.json</code> the standard configuration is: <pre><code>\"roi\": {\n    \"0\": 5,\n    \"60\": 4,\n    \"120\": 3\n  }\n</code></pre> This configuration can be interpreted as:  - When ROI is equal to 5%, close the trade immediately. - When ROI is equal to 4%, close the trade after 60 minutes. - When ROI is equal to 3%, close the trade after 120 minutes.</p>","title":"ROI"},{"location":"your_first_strategy/editing_your_configuration/#trading-pairs","text":"<p>Specifies which pairs you want the bot to trade. Make sure that when specifying the list of <code>pairs</code> that the base for each pair needs to be the same and equal to the defined <code>currency</code>.</p>","title":"Trading pairs"},{"location":"your_first_strategy/editing_your_configuration/#fee","text":"<p>Defines the <code>fee</code> percentage. This percentage will be applied on every trade entry and exit.</p>","title":"Fee"},{"location":"your_first_strategy/editing_your_configuration/#strategy","text":"<p>Specifies which strategy to backtest. Make sure the <code>strategy-name</code> is equal to the name of the strategy class (not the name of the <code>.py</code> file). Furthermore, make sure the <code>.py</code> file that contains the strategy class is  saved in the <code>strategies-folder</code>.</p>","title":"Strategy"},{"location":"your_first_strategy/editing_your_configuration/#plots","text":"<p>After each backtest there is the possibility to see a plot of the change in price, buy/sell signals (both executed and  not executed) and indicators. This function is automatically enabled and can be disabled by settings the <code>plots</code>  boolean to <code>false</code>. The indicators in the plots can be configured by changing the value for either  <code>mainplot_indicators</code> and/or <code>subplot_indicators</code>. Make sure when adding new indicators to the list of plot-indicators, that these indicators are populated in the strategy.</p>","title":"Plots"},{"location":"your_first_strategy/results_explained/","text":"<p>Now that you have a good grasp of the basics of the sample strategy, it is time to test it out by running a backtest. Once you have installed the Engine following the instructions in Section 1.1: Installation, simply navigate to the folder where you created your project, and run the command \u2018engine\u2019. This will run the Engine, and you will be presented with the results of your strategy. The results are divided into a few categories. The first one is: the Main Results.</p>","title":"Results Explained"},{"location":"your_first_strategy/results_explained/#main-results","text":"<p>  This is how the first section of your results look like. The Main Results are divided into three separate tables: Settings, Performance, and Trade Info.</p>","title":"Main Results"},{"location":"your_first_strategy/results_explained/#settings","text":"<p>This table shows the settings that you used while testing your algorithm. If you are unsure what the different settings mean, we explain them in Section 2.5: Editing Your Configuration.</p>","title":"Settings"},{"location":"your_first_strategy/results_explained/#performance","text":"<p>This table shows the performance of the strategy (on portfolio level, so not divided by coin). A brief explanation of each of the terms used:</p> <ul> <li>End capital: total amount of capital at the end of backtesting period. This capital is the sum of your current budget (the available funds that can be used to start new trades) and the total worth of your open trades (converted to your base currency).</li> <li>Overall profit: total profit percentage (100 * starting capital / end capital)</li> <li>Max. realised drawdown: for a more detailed explanation, see the Termsheet.</li> <li>Max. seen drawdown: for a more detailed explanation, see the Termsheet.</li> <li>Max. seen drawdown from: the starting date of the drawdown period where the max. seen drawdown occurred.</li> <li>Max. seen drawdown to: the end date of the drawdown period where the max. seen drawdown occurred. If this is a \u2018-\u2019 instead of a date, that means that the drawdown period has not yet ended when the backtest concluded.</li> <li>Max. seen drawdown at: the specific date and time at which the max. seen drawdown occurred.</li> <li>Market change coins: the average market change of the whitelisted coins within the backtesting period.</li> <li>Market change BTC: the market change of BTC/USDT within the backtesting period.</li> <li>Market drawdown coins: max. seen drawdown of the market change of the whitelisted coins.</li> <li>Market drawdown BTC: max. seen drawdown of the market change of BTC/USDT.</li> <li>Total fee paid: summed total of all paid fees (including open trade fees)</li> </ul>","title":"Performance"},{"location":"your_first_strategy/results_explained/#trade-info","text":"<p>This table shows the trade information combined over all whitelisted coins. A brief explanation of each of the terms used:</p> <ul> <li>Amount of trades: total number of times the strategy has opened (buy) and closed (sell) a trade. Left-open trades (trades that are bought but not sold yet, by the time the backtesting period ended) are not counted in this.</li> <li>Avg. trades per day: average amount of trades the strategy has performed per day.</li> <li>Left-open trades: total amount of trades which were opened but not closed.</li> <li>Volume turnover (Monthly avg.): the average volume turnover per month. Includes only closed trades.</li> <li>Trades with loss: total amount of trades that have closed with a negative profit percentage.</li> <li>Most consecutive losses: maximum number of trades that closed in succession with each trade having a negative profit percentage (combined over all whitelisted coins).</li> <li>Best trade: profit percentage of the trade with the highest profit percentage.</li> <li>Worst trade: profit percentage of the trade with the lowest profit percentage.</li> <li>Shortest trade duration: duration of the trade with the shortest duration between opening and closing.</li> <li>Avg. trade duration: average duration between opening and closing a trade.</li> <li>Longest trade duration: duration of the trade with the longest duration between opening and closing.</li> <li>Sharpe ratio (90d / 3y): Sharpe ratio for a timeperiod of 90 days and 3 years. Defaults to the timeperiod in the config file if it isn't long enough.</li> <li>Sortino ratio (90d / 3y): Sortino ratio for a timeperiod of 90 days and 3 years. Defaults to the timeperiod in the config file if it isn't long enough.</li> <li>Weekly perf. vs market (W/D/L): amount of weeks in which the profits from the strategy outperformed the average marketchange for whitelisted coins. W/D/L indicating how many weeks were labeled as Wins, Losses, and Draws respectively.</li> </ul>","title":"Trade Info"},{"location":"your_first_strategy/results_explained/#coin-insights","text":"<p>  Underneath the Main Results section is the Coin Insights section. This section shows the results of the trading strategy, separated per whitelisted coin. This can give you a good insight into how your strategy performance differs between coins.</p>","title":"Coin Insights"},{"location":"your_first_strategy/results_explained/#coin-performance","text":"<p>The first table in the Coin Insights section is the Coin Performance table. This shows the performance of the strategy on coin level. A brief description of the terms used:</p> <ul> <li>Avg. profit (%): the average profit percentage over all trades for that coin.</li> <li>Cum. profit (%): the cumulative profit percentage over all trades for that coin. Here, we define cumulative as the sum over all trade profit percentages.</li> <li>Total profit (%): Total profit percentage over all trades for that coin. This is defined as the product over all trade profit percentages.</li> <li>Profit ($): Total amount of profit in USDT over all trades for that coin. For calculating the profit (in USDT) for a particular coin, the fee for both opening and closing a trade is subtracted from the profit.</li> </ul>","title":"Coin Performance"},{"location":"your_first_strategy/results_explained/#coin-metrics","text":"<p>The second table in the Coin Insights section is the Coin Metrics table. This table shows important metrics for each coin. </p> <ul> <li>Market change (%): the market change for the corresponding coin.</li> <li>Market drawdown (%): the max. seen drawdown of the market change for the corresponding coin.</li> <li>Max. seen drawdown (%): the max. seen drawdown for all closed trades for that coin.</li> <li>Max. realised drawdown (%): max. realised drawdown for all closed trades for that coin .</li> <li>Weekly perf. vs market (W/D/L): amount of weeks in which the profits for that coin from the strategy outperformed the average market change for that coin. W/D/L indicating how many weeks were labeled as Wins, Losses, and Draws respectively.</li> </ul>","title":"Coin Metrics"},{"location":"your_first_strategy/results_explained/#coin-signals","text":"<p>The third and final table in the Coin Insights section is the Coin Signals table. This table shows information about the trades closed for each coin.</p> <ul> <li>Trades (W/L): number of trades the corresponding coin has been able to open and close. The (W/L) numbers indicate the amount of trades closed with a positive and a negative profit margin, respectively.</li> <li>Shortest trade duration: duration of the trade with the shortest duration between opening and closing.</li> <li>Avg. trade duration: average duration between opening and closing a trade.</li> <li>Longest trade duration: duration of the trade with the longest duration between opening and closing.</li> <li>ROI: amount of times a trade has been closed because of the profit margin reaching (one of the) the specified ROI level(s).</li> <li>SL: amount of times a trade has been closed because of the profit margin dipping beneath the specified stoploss.</li> <li>Signal: amount of times a trade has been closed because of a strategy sell signal.</li> </ul>","title":"Coin Signals"},{"location":"your_first_strategy/results_explained/#left-open-trades","text":"<p>  The final section of the Backtesting Results is the Left Open Trades section. This section shows the intermediate results of the trades that were not closed by the time the backtesting period ended. If there were no open trades at the end of the backtesting period, this table will be empty.</p> <ul> <li>Cur. profit (%): the current profit percentage of the open trade.</li> <li>Cur. profit ($): the current profit in USDT of the open trade.</li> <li>Max. seen drawdown (%): the current max. seen drawdown of the open trade.</li> <li>Opened at: the date and time at which the trade has been opened.</li> </ul>","title":"Left Open Trades"},{"location":"your_first_strategy/results_explained/#plots","text":"<p>If you want a more detailed view of how your algorithm performed over time, you can find two categories of plots that can help you achieve that. After you run the Engine for the first time, the plots will be located in the folder DIRECTORY_NAME/data/backtesting-data/plots.</p>","title":"Plots"},{"location":"your_first_strategy/results_explained/#coin-plot","text":"<p>  The coin plots are located directly in the plots folder, and are named plotCOINNAME.html (for example the BTC/USDT Plot is in the file plotBTCUSDT.html). The plot shows the fluctuation of the value of the coin. If you zoom in, you can see the OHLC candle for each timestep. The bottom graph by default shows the volume of the coin at each timestep. You can add or change any indicators shown in these plots, by changing your config file. Find out how to do that in Section 2.5: Editing Your Configuration.</p>","title":"Coin Plot"},{"location":"your_first_strategy/results_explained/#equity-plot","text":"<p>  The equity plot can be found in the plots/equity folder. This graph shows the capital of your trading algorithm over time. The horizontal parts of the graph signify moments where the algorithm had no trades open.</p> <p>Depending on your preference, you can toggle between a linear view and a logarithmic view of the y-axis. Furthermore, in the top right of the plot you will find a menu bar with several functionalities like: export, zoom, pan, and more.</p>","title":"Equity Plot"},{"location":"your_first_strategy/results_explained/#trade-logs","text":"<p>If you need an even more detailed insight into the behaviour of the trading algorithm, you can take a look at the trades log. This is where all trades of the algorithm are logged in json format. You can find the trades log in the following file: DIRECTORY_NAME/data/backtesting-data/trades_log.json. One single trade in the trades log looks like this:</p> <pre><code>\"1\": {\n   \"status\": \"closed\",\n   \"opened_at\": \"2021-01-04 10:30:00\",\n   \"closed_at\": \"2021-01-04 15:30:00\",\n   \"pair\": \"BTC/USDT\",\n   \"open_price\": 31038.63,\n   \"close_price\": 31969.788900000003,\n   \"fee_paid_open\": 0.8430018055555556,\n   \"fee_paid_close\": 0.8745300730833334,\n   \"fee_paid_total\": 1.717531878638889,\n   \"starting_amount\": 333.3333333333333,\n   \"capital\": 341.61881250000005,\n   \"currency_amount\": 0.01071245734750535,\n   \"sell_reason\": \"SellReason.ROI\"\n}\n</code></pre> <p>This includes the following statistics:</p> <ul> <li>Status: Open or Closed - signifies the current status of the trade.</li> <li>Opened at: The date and time the trade was opened.</li> <li>Closed at: The date and time the trade was closed. Will be null when the trade is still open.</li> <li>Pair: The coin that was traded.</li> <li>Open price: The price in base currency on the moment the trade was opened</li> <li>Close price: The price in base currency on the moment the trade was closed. Will be null when the trade is still open.</li> <li>Fee paid open: The amount that was paid in buy-fees.</li> <li>Fee paid close: The amount that was paid in sell-fees, if applicable.</li> <li>Fee paid total: The total amount that was paid in buy- and sell-fees.</li> <li>Starting amount: The amount of base currency that the trade was worth when it was opened.</li> <li>Capital: The amount of base currency that the trade was worth when it was sold, or the current amount that it was worth at the end of the backtesting period, if trade is still open.</li> <li>Currency amount: The amount of the Crypto currency that was bought in the trade.</li> <li>Sell reason: The reason why the trade was closed. Can be one of the following: SELL_SIGNAL (when it was closed because a sell signal was sent), ROI (when it was closed because one of the ROI targets was hit), STOPLOSS (when it was closed because the stoploss was hit), or NONE (when the trade is still open).</li> </ul>","title":"Trade Logs"},{"location":"your_first_strategy/stoploss_and_roi/","text":"","title":"Stoploss and ROI"},{"location":"your_first_strategy/stoploss_and_roi/#configuration","text":"<p>In the <code>config.json</code> file you will find all necessary and important configuration options.</p>","title":"Configuration"},{"location":"your_first_strategy/stoploss_and_roi/#roi","text":"<p>The ROI table in the configuration is used to sell at a certain percentage of profit after a defined time. The <code>keys</code> in the dictionary are in minutes, the <code>values</code> are the percentages. Keys should always be an <code>int</code> (round number) with double quotes. Value could be an <code>int</code>(round number) or a <code>float</code> (with decimals).</p> <pre><code>   \"roi\": {\n     \"0\": 5,\n     \"60\": 4,\n     \"120\": 3.5\n   }\n</code></pre> <p>This configuration means positions will always be closed if the profit is higher than 5%. After an hour (60 minutes) the position will automatically be closed if the profit is higher than 4%. Even the smallest change in the ROI could mean a huge difference when it comes to profit.</p>","title":"ROI"},{"location":"your_first_strategy/stoploss_and_roi/#stop-loss","text":"","title":"Stop loss"},{"location":"your_first_strategy/stoploss_and_roi/#how-to-use-stop-loss","text":"<p>A Stop-Loss is an advanced order that is used by traders that limits any form of additional losses. When a specific price is met, the order is triggered.</p> <p>An example would be that buying in at 100 would stop any form of losses at 95. In this case the stop-loss treshold would be -5%. Similarly, it can be done for a profit where one can set it to +5%, which in turn would mean the profit would be capped at 105.</p> <p>This in itself can be modified in any increment. The stoploss (SL) function is to prevent extreme loses. The SL value in the configuration file could be a <code>float</code>(with decimals) or an <code>int</code>(round number).</p> <pre><code>   \"stoploss\": \"-0.5\",\n</code></pre> <p>This configuration means positions will always be closed if the profit is lower than -0.5%.</p>","title":"How to use 'Stop Loss'"},{"location":"your_first_strategy/stoploss_and_roi/#custom-stop-loss","text":"<p>Alternatively, currently we have 3 options in terms of stop loss configurations.</p> <p><pre><code>  {\n    \"name\": \"stoploss-type\",\n    \"default\": \"standard\",\n    \"options\": [\"standard\", \"trailing\", \"dynamic\"],\n    \"type\": \"string\",\n    \"cli\": {\n      \"short\": \"sl_type\"\n    }\n  }\n</code></pre> As seen in the code above, these three consists out of the following:</p> <ul> <li>'standard' -&gt; standard stoploss calculation based on the price when opening a trade (requires 'stoploss' percentage)</li> <li>'trailing' -&gt; trailing stoploss function (requires 'stoploss' percentage)</li> <li>'dynamic' -&gt; configurable stoploss function that can be changed in my_strategy_advanced.py</li> </ul> <p>In the advanced_strategy.py file an example can be seen in terms of the 'dynamic' stop loss; the snippet of code underneath is what you'd find in the file. Following the presented code, you'll be able to implement a dynamic stop loss.</p> <pre><code>def stoploss(self, dataframe: DataFrame) -&gt; DataFrame:\n        \"\"\"\n        Override this method if you want to dynamically change the stoploss \n        for every trade. If not, the stoploss provided in config.json will\n        be returned.\n        IMPORTANT: this function is only called when in the config.json \"stoploss-type\" is:\n            -&gt;  \"stoploss-type\": \"dynamic\"\n        :param dataframe: dataframe filled with indicators from generate_indicators\n        :type dataframe: Dataframe\n        :return: dataframe filled with dynamic stoploss signals\n        :rtype: DataFrame\n        \"\"\"\n        # BEGIN STRATEGY\n\n        dataframe['stoploss'] = dataframe['ema5']\n\n        # END STRATEGY\n\n        return dataframe\n</code></pre>","title":"Custom Stop loss"},{"location":"your_first_strategy/stoploss_and_roi/#ohlcv","text":"<p>OHLCV, also known as:</p> <ul> <li>Open</li> <li>High</li> <li>Low</li> <li>Close</li> <li>Volume</li> </ul> <p>Can be used to trade in an easy fashion. A simple example for this would be by using the close. The close is the end value of the current candle, where it closes and goes into a new candle.</p> <p><pre><code>dataframe.loc[\n    (\n        (dataframe['close'] &lt; 50)\n    ),\n    'buy'] = 1\n</code></pre> Which means you'll buy an asset when the close is below 50. This can be adjusted as you see fit, however, the general jist of it is that all the OHLCV can be used in a similar fashion.</p>","title":"OHLCV"},{"location":"your_first_strategy/stoploss_and_roi/#how-to-use-if-statements-with-candles-and-elucidating-timeframes","text":"<p>When generating your indicators, ensure that what you type down makes sense. For example:</p> <pre><code>if current_candle['close'] &gt; current_candle['ma200']:\n</code></pre> <p>Will result in an error due to the fact that the candle will be marked as close yet it is supposed to surpass the past 200 point timeframe average.</p> <p>A correct example on how to use an if statement would be:</p> <pre><code>if int(timestamp) &gt; time:\n                ohlcv = data_dict[timestamp]\n</code></pre> <p>Or</p> <pre><code>dataframe.loc[\n    (\n        (dataframe['ma10'] &lt; dataframe['ma100'])\n    ),\n    'buy'] = 1\n</code></pre> <p>Albeit, the latter is already a timeframe module and would already be a part of a possible strategy. </p> <p>Changing the timeframe can make a huge difference; if you apply a short timeframe and put it up against a large timeframe as presented in the second example, you can detect shorts and act on them!</p>","title":"How to use 'if statements with candles' and elucidating timeframes"},{"location":"your_first_strategy/stoploss_and_roi/#plotting","text":"<p>The plotting functionality can give you a more in-depth insight in the behaviour of the indicators you use, and the buy and sell signals that your algorithm generates. In order to activate this functionality, set \u2018plots\u2019 to true in your config file,  and add the main plot and subplot indicators you wish to see.</p> <pre><code>  \"plots\": true,\n  \"mainplot_indicators\": [\"ema5\", \"ema21\"],\n  \"subplot_indicators\": [\"volume\"]\n</code></pre> <p>The plots will be done per coin, and can for example be found here: data/backtesting-data/binance/plotETHUSDT.html</p>","title":"Plotting"},{"location":"your_first_strategy/stoploss_and_roi/#getting-started","text":"<p>Now you've seen how we configured all the basic settings and buy/sell signals. From now on, you can start working on your very own trading algorithms.</p>","title":"Getting started"},{"location":"your_first_strategy/strategy_explained/","text":"<p>After installing the Engine, it is time to start working on a strategy of your own. In this chapter you will learn how to get started with developing your very own strategy. To give you a head start, we have included a sample strategy which can be found in the file /strategies/my_strategy.py (where you just created the project, as explained in Section 1.2: Running). We will use this sample strategy to explain the main concepts of strategies.","title":"Strategy Explained"},{"location":"your_first_strategy/strategy_explained/#generate-indicators","text":"<p>The first function in the 'my_strategy.py' file is the generate_indicators function. This function, like the name implies, generates indicators, which in turn are used to calculate when to buy, and when to sell. The function looks like this:</p> <pre><code>def generate_indicators(self, dataframe: DataFrame, additional_pairs=None) -&gt; DataFrame:\n   \"\"\"\n   :param dataframe: All passed candles (current candle included!) with OHLCV data\n   :type dataframe: DataFrame\n   :param additional_pairs: Possible additional pairs with specified timeframe\n   :type additional_pairs: dict\n   :return: Dataframe filled with indicator-data\n   :rtype: DataFrame\n   \"\"\"\n   # RSI - Relative Strength Index\n   dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n\n   # EMA - Exponential Moving Average\n   dataframe['ema5'] = ta.EMA(dataframe, timeperiod=5)\n   dataframe['ema21'] = ta.EMA(dataframe, timeperiod=21)\n\n   return dataframe\n</code></pre> <p>The sample strategy is based on two indicators: the RSI (Relative Strength Index) and two versions of the EMA (Exponential moving average): EMA5, which averages over the last 5 timesteps, and EMA21, which averages over the last 21 timesteps.</p> <p>You probably want to add more indicators on which to base your buy and sell signals, when you start developing your own strategy - be sure to add them to the dataframe (the collection of data) in the same way as in the code above. For example, if you want to add SMA5 (Simple Moving Average over the last 5 timesteps), just add the following line before the \u2018return dataframe\u2019 line:</p> <pre><code>dataframe['sma5'] = ta.SMA(dataframe, timeperiod=5)\n</code></pre> <p>For more examples of indicators and how to use them, you can take a look at the file /strategies/indicator_sample.py - a large amount of indicators is shown there. Just take your pick, and copy the (uncommented) line to your strategy file.  <p>Attention</p> <p>If you use an indicator with a large amount of timesteps necessary, beware: if the indicator needs more timesteps than there are candles in your dataset, you will get errors or distorted results. Please make sure your timeframe is sufficiently small, and your backtesting period is sufficiently large, so you have enough candles in your backtest to base your indicators upon. For more information about how to configure the timeframe and backtesting period, see Section 2.4: Editing your configuration.</p>   <p>Note</p> <p>If you use a TA-Lib function (any ta.FUNCTION_HERE function, like the RSI, EMA, and SMA used above) be sure to include a \u2018timeperiod\u2019 explicitly, otherwise it will be set to a default timeperiod of two weeks. So be sure to change this: <pre><code>dataframe['rsi'] = ta.RSI(dataframe)\n</code></pre> To this: <pre><code>dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)\n</code></pre></p>","title":"Generate Indicators"},{"location":"your_first_strategy/strategy_explained/#buy-signal","text":"<p>In order for your strategy to buy crypto, you will need to generate \u2018buy signals\u2019. These signify points where you want your strategy to buy. These are usually based on the indicators; when they reach a certain condition, a buy signal should be generated. In the sample strategy file, the function to generate buy signals looks like this:</p> <pre><code>def buy_signal(self, dataframe: DataFrame) -&gt; DataFrame:\n   \"\"\"\n   :param dataframe: Dataframe filled with indicators from generate_indicators\n   :type dataframe: DataFrame\n   :return: dataframe filled with buy signals\n   :rtype: DataFrame\n   \"\"\"\n   # BEGIN STRATEGY\n\n   dataframe.loc[\n       (\n           (dataframe['rsi'] &lt; 30) &amp;\n           (dataframe['ema5'] &lt; dataframe['ema21']) &amp;\n           (dataframe['volume'] &gt; 0)\n       ),\n       'buy'] = 1\n\n   # END STRATEGY\n\n   return dataframe\n</code></pre> <p>This code generates a buy signal (buy = 1) for every timestep where the rsi is below 30, and the ema5 is below the ema21. The last line, volume &gt; 0, means that you should only generate a buy signal when there is volume, ergo when trades are actually being made. While you are encouraged to change the other buy conditions, you should keep the volume condition in your strategy! You can change the conditions by removing and/or adding lines. Keep in mind that a buy signal only translates into an actual buy if your algorithm is not already in position, and if there is enough open budget left to open a trade with.</p>","title":"Buy Signal"},{"location":"your_first_strategy/strategy_explained/#sell-signal","text":"<p>The function to generate the sell signal is very similar to the buy_signal function. The function generates points on which you want your algorithm to sell. The code looks as follows:</p> <pre><code>def sell_signal(self, dataframe: DataFrame) -&gt; DataFrame:\n   \"\"\"\n   :param dataframe: Dataframe filled with indicators from generate_indicators\n   :type dataframe: DataFrame\n   :return: dataframe filled with sell signals\n   :rtype: DataFrame\n   \"\"\"\n   # BEGIN STRATEGY\n\n   dataframe.loc[\n       (\n           (dataframe['rsi'] &gt; 70) &amp;\n           (dataframe['volume'] &gt; 0)\n       ),\n       'sell'] = 1\n\n   # END STRATEGY\n\n   return dataframe\n</code></pre> <p>In this sample strategy, a sell signal is generated whenever the RSI indicator goes above the value of 70. Keep in mind that a sell signal only translates into an actual sell if the algorithm is already in position - if it hasn\u2019t bought first, it cannot sell!</p>  <p>Note</p> <p>Apart from a generated sell signal, positions can also be closed (sold) by a triggered Stoploss or ROI (Return on Investment). These can be set in your configuration file, and will be discussed more thoroughly in the Section 2.3: Editing the Stoploss and ROI.</p>","title":"Sell Signal"}]}